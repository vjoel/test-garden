require 'wrong'
include Wrong::Assert

# A garden of forking tests.[1]
#
# TestGarden is a testing framework for concisely sharing several stages of
# setup code across tests. The shared code is executed once for each test
# that needs it. Tests may be nested to any depth.
#
# TestGarden generates summary output, reporting how many pass, fail, skip,
# and error cases were detected for each group of tests. TestGarden assumes
# assertion failure exceptions are generated by Wrong::Assert#assert.
#
# Synopsis:
#
#   require 'test-garden'
#
#   test Thing do
#     thing = Thing.new; teardown {thing.cleanup()}
#     assert {thing.ok?}
#
#     test "assign foo" do
#       thing.foo = "baz" # does not affect foo in subsequent tests
#       assert {thing.foo == "baz"}
#     end
#
#     test "compare foo in two instances" do
#       thing2 = Thing.new; teardown {thing2.cleanup()}
#       assert {thing.foo == thing2.foo}
#     end
#   end
#
# Run the test like so:
#
#   ruby test_thing.rb [-v | --verbose] [topic topic ...]
#
# If no topics are given, the verbose output is:
#
#   T: Thing
#   T: Thing: assign foo
#   T: Thing
#   T: Thing: compare foo in two instances
#     4 passed,   0 failed,   0 skipped,   0 errors in Thing
#
# If a topic list is given, it is treated as a sequence of regular expressions.
# Only tests whose topic path matches those regular expressions, one for one,
# are executed. (Matching is case insensitive.) For example:
#
#   ruby testfilename.rb thing compare
#
# This executes only the the last test. The verbose output is:
#
#   T: Thing
#   T: Thing
#   T: Thing: compare foo in two instances
#     3 passed,   0 failed,   1 skipped,   0 errors in Thing
#
# Note that the "assign foo" test was skipped, and counted as such.
#
class TestGarden
  # Array of nested topics in descending order from the main topic to the topic
  # of the current test.
  attr_reader :stack
  
  # Hash of counters for pass, fail, skip, error cases.
  attr_reader :status
  
  # Array of regexes that restrict which topics are traversed.
  attr_reader :pattern
  
  # Stack of arrays of procs that will be called tear down the current setup.
  attr_reader :teardowns
  
  # Reads params from command line, or from given array of strings. If
  # passing an array, you should call this method *before* all tests.
  def self.params argv=ARGV
    @params ||= {
      :verbose => argv.delete("-v") || argv.delete("--verbose"),
      :pattern => argv.map {|arg| /#{arg}/i}
    }
  end
  
  # By default, share params for all TestGardens, but allow per-instance
  # variation by modifying the params hash.
  def params
    @params ||= self.class.params.dup
  end
  
  def initialize
    @pos = []
    @next = nil
    @did_one_test = false
    @stack = []
    @status = Hash.new(0)
    @enabled = false
    @pattern = params[:pattern]
    @teardowns = []
  end
  
  def enabled?
    @enabled
  end
  
  def verbose?
    params[:verbose]
  end

  def nest topic
    topic = topic.to_s
    @main_topic ||= topic

    if @did_one_test
      if not @next
        @next = @pos.dup
      end
      @pos[-1] += 1 if @pos.length > 0
      return
    end
    
    if @next
      len = [@pos.length, @next.length].min
      if @next[0...len] != @pos[0...len]
        @pos[-1] += 1 if @pos.length > 0
        return
      end
      
      if @next == @pos
        @next = nil
      end
    end
        
    begin
      stack.push topic
      @pos << 0
      teardowns << []
      old_enabled = @enabled
      @enabled = pattern.zip(stack).all? {|pat,subj| !subj or pat === subj}
      if enabled?
        if verbose?
          puts "T: #{stack.join(": ")}"
        end
        catch :break_test do
          yield
        end
      else
        status[:skip] += 1
      end
    
    ensure
      teardowns.pop.reverse_each {|block| block.call}
      @enabled = old_enabled
      @pos.pop
      stack.pop
      @did_one_test = true
      @pos[-1] += 1 if @pos.length > 0
    end
  end
  
  def print_report
    ps = "%3d passed" % status[:pass]
    fs = "%3d failed" % status[:fail]
    fs = fs.color(:yellow) if status[:fail] > 0
    ss = "%3d skipped" % status[:skip]
    es = "%3d errors" % status[:err]
    es = es.color(:red) if status[:err] > 0
    report = [ps,fs,ss,es].join(", ")
    puts "#{report} in #{@main_topic}"
  end

  def handle_test_results
    yield

  rescue Wrong::Assert::AssertionFailedError => ex
    status[:fail] += 1
    line = nil
    ex.backtrace.reverse_each {|l| break if /wrong\/assert.rb/ =~ l; line = l}
    msg = "F: #{stack.join(": ")}: failed assertion, at #{line}"
    puts msg.color(:yellow), ex.message
    throw :break_test

  rescue => ex
    status[:err]  += 1
    bt = []
    ex.backtrace.each {|l| break if /wrong\/assert.rb/ =~ l; bt << l}
    bts = bt.join("\n  from ")
    msg = "E: #{stack.join(": ")}: #{ex} (#{ex.class}), at #{bts}"
    puts msg.color(:red)
    throw :break_test

  else
    if enabled?
      status[:pass] += 1
    else
      raise
    end
  end
  
  def main topic
    begin
      nest topic do
        handle_test_results do
          yield
        end
      end
      @did_one_test = false
    end while @next
  ensure
    print_report
  end
end

# Begin a test block. The topic can be any object; its to_s method is applied
# to generate the output string. A class or string is typical.
#
# The block can include essentially any code, including more #test calls,
# method calls that call #test, assert{} and teardown{} calls, etc.
#
def test topic
  if @test
    @test.nest topic do
      @test.handle_test_results do
        yield
      end
    end
    
  else
    begin
      @test = TestGarden.new
      @test.main topic do
        yield
      end
    ensure
      @test = nil
    end
  end
end

# Alternative to putting the teardown code after all relevant tests.
# This can be used to keep related setup and teardown code together.
# Teardows are executed in the reverse of their creation order.
def teardown(&block)
  if @test
    @test.teardowns.last << block
  else
    raise "Cannot teardown: not in a test"
  end
end

# [1] In reference to "The garden of forking paths", by J.L. Borges.
